import type { JsonAttribute, ResourceAttributeSource } from './attributes';
import type { Clock } from './clock';
import type { Configuration, InternalConfiguration } from './config';
import type { JsonEvent } from './events';
import type { Kind, SpanEnded } from './span';
export type DeliveryFactory = (endpoint: string) => Delivery;
export type ResponseState = 'success' | 'failure-discard' | 'failure-retryable';
interface Response {
    state: ResponseState;
    samplingProbability?: number;
}
export interface Delivery {
    send: (payload: TracePayload) => Promise<Response>;
}
interface Resource {
    attributes: Array<JsonAttribute | undefined>;
}
interface ScopeSpan {
    spans: DeliverySpan[];
}
interface ResourceSpan {
    resource: Resource;
    scopeSpans: ScopeSpan[];
}
export interface DeliveryPayload {
    resourceSpans: ResourceSpan[];
}
export interface DeliverySpan {
    name: string;
    kind: Kind;
    spanId: string;
    traceId: string;
    parentSpanId?: string;
    startTimeUnixNano: string;
    endTimeUnixNano: string;
    droppedAttributesCount?: number;
    attributes: Array<JsonAttribute | undefined>;
    events: JsonEvent[];
}
export interface TracePayload {
    body: DeliveryPayload;
    headers: {
        'Bugsnag-Api-Key': string;
        'Content-Type': 'application/json';
        'Bugsnag-Span-Sampling'?: string;
        'Bugsnag-Sent-At'?: string;
    };
}
export declare class TracePayloadEncoder<C extends Configuration> {
    private readonly clock;
    private readonly configuration;
    private readonly resourceAttributeSource;
    constructor(clock: Clock, configuration: InternalConfiguration<C>, resourceAttributeSource: ResourceAttributeSource<C>);
    encode(spans: SpanEnded[]): Promise<TracePayload>;
    generateSamplingHeader(spans: SpanEnded[]): string;
}
export declare function responseStateFromStatusCode(statusCode: number): ResponseState;
export {};
//# sourceMappingURL=delivery.d.ts.map