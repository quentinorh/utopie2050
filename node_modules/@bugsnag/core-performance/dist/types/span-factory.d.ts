import type { SpanAttribute, SpanAttributesSource } from './attributes';
import type { BackgroundingListener } from './backgrounding-listener';
import type { Clock } from './clock';
import type { Configuration, InternalConfiguration, Logger } from './config';
import type { IdGenerator } from './id-generator';
import type { NetworkSpanOptions } from './network-span';
import type { Processor } from './processor';
import type { ReadonlySampler } from './sampler';
import type { InternalSpanOptions, Span, SpanOptionSchema, SpanOptions } from './span';
import { SpanInternal } from './span';
import type { SpanContextStorage } from './span-context';
export declare const DISCARD_END_TIME = -1;
export declare class SpanFactory<C extends Configuration> {
    private processor;
    readonly sampler: ReadonlySampler;
    private readonly idGenerator;
    private readonly spanAttributesSource;
    private readonly clock;
    private readonly spanContextStorage;
    private logger;
    private spanAttributeLimits;
    private openSpans;
    private isInForeground;
    constructor(processor: Processor, sampler: ReadonlySampler, idGenerator: IdGenerator, spanAttributesSource: SpanAttributesSource<C>, clock: Clock, backgroundingListener: BackgroundingListener, logger: Logger, spanContextStorage: SpanContextStorage);
    private onBackgroundStateChange;
    startSpan(name: string, options: SpanOptions): SpanInternal;
    startNetworkSpan(options: NetworkSpanOptions): SpanInternal;
    configure(processor: Processor, configuration: InternalConfiguration<C>): void;
    endSpan(span: SpanInternal, endTime: number, additionalAttributes?: Record<string, SpanAttribute>): void;
    toPublicApi(span: SpanInternal): Span;
    validateSpanOptions<O extends SpanOptions>(name: string, options: unknown, schema?: SpanOptionSchema): InternalSpanOptions<O>;
}
//# sourceMappingURL=span-factory.d.ts.map